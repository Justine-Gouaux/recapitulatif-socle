# SAISON 3 - INTERACTIONS

## Contenu

- [SAISON 3 - INTERACTIONS](#saison-3---interactions)
  - [Contenu](#contenu)
  - [JAVASCRIPT](#javascript)
    - [Syntaxe JS](#syntaxe-js)
      - [Types de variables](#types-de-variables)
      - [Opérations et raccourcis](#opérations-et-raccourcis)
      - [Concaténation](#concaténation)
    - [Fonctions](#fonctions)
    - [Conditions](#conditions)
    - [Boucles](#boucles)
      - [Boucle WHILE](#boucle-while)
      - [Boucle DO...WHILE](#boucle-dowhile)
      - [Boucle FOR](#boucle-for)
      - [Boucle FOR...IN](#boucle-forin)
      - [Boucle FOR...OF](#boucle-forof)
    - [Enumérable VS itérable](#enumérable-vs-itérable)
    - [Modules JS](#modules-js)
      - [Ressources](#ressources)
  - [DOM](#dom)
      - [Ressources](#ressources-1)
    - [Evènements](#evènements)
      - [Ressources](#ressources-2)
  - [Cookies & Local Storage](#cookies--local-storage)
    - [Cookies &#127850;](#cookies-)
      - [Ressources](#ressources-3)
    - [Local Storage](#local-storage)
    - [Documentation](#documentation)


## JAVASCRIPT

JavaScript (souvent abrégé en *JS*) est un langage de script léger, **orienté objet**, principalement connu comme le **langage de script** des pages web. Il gère les interactions entre l'utilisateur et le navigateur et permet un évolution dynamique d'un contenu.

On utilise l'élément `<script>` pour ajouter du JavaScript à un document HTML, que l'on conseille de placer à la fin du `<body>` pour éviter de ralentir le chargement et l'affichage du contenu.

Le JS est exécuté par le moteur JS du navigateur, après que le HTML et le CSS ont été assemblés et combinés en une page web. Cet enchaînement est nécessaire pour être sûr que la structure et le style de la page sont déjà en place quand le JS commence son exécution.

### Syntaxe JS

Pour créer une variable en JS, on utilise les mots-clés `let` si celle-ci est amenée à être modifiée ou `const` si sa valeur reste constante (ou `var`) et on utilise généralement la convention de nommage *camelCase*.

On peut assigner à une valeur à une variable directement lors de sa création, grâce à l'opérateur `=`; autrement sa valeur sera `undefined`.

Pour voir ce que contient une variable, on peut utiliser la fonction `console.log()`.

#### Types de variables

Le type d'une variable est défini en fonction de la valeur qu'elle stocke, et permet de lui appliquer certains traitements spécifiques.

- `number` : tout nompbre, entier ou décimal
- `boolean`
- `string`
- `array` : tableau dans lequel case est assignée à un index numérique (démarrant à 0) et peut contenir une varible de tout type (tableau compris)
- objet : type permettant de stocker plusieurs valeurs indexées par clés (= **structure clé: valeur**). On accède aux éléments d'un objet avec les notations:
  - `objectName["key"]`
  - `objectName.key`

Le mot-clé `typeof` permet de vérifier le type d’une variable.

#### Opérations et raccourcis

Parmi tous les opérateurs disponibles en JS, les opérateurs arithmétiques (`+`, `-`, `*`, `/`, `%`) permettent d’éxécuter les calculs de base sur des `number`.

Certains opérateurs dits *raccourcis* permettent de faire 2 opérations en 1 instruction : `+=` (= **incrémentation**), `-=` (= **décrémentation**), `*=` et `/=`.

Il est possible de gérer l’incrémentation ou la décrémentation de 1 avec respectivement `++` et `--`.

Il est possible de combiner des valeurs booléennes, avec les opérateurs `&&` (= **ET**) et `||` (= **OU**).

On peut comparer *la valeur* de deux variables avec `==` et *la valeur ET le type* de deux variables avec `===` (mais aussi avec `<`, `<=`, `>`, `>=`).

#### Concaténation

Pour concaténer des *string*, ou des variables contenant des *string*, on utilise l’opérateur `+`.

### Fonctions

Le cœur de JavaScript est constitué de fonctionnalités communes de programmation permettant entre autre de :

- **stocker des valeurs** utiles dans des variables
- **faire des opérations** sur des morceaux de texte (= *strings* )
- **exécuter du code** en réponse à certains événements se produisant sur une page web

### Conditions

De la même façon qu'en php, la structure de contrôle `if` attend une condition qui s’évalue à `true` ou `false` pour savoir si elle doit exécuter le bloc de code qui lui est associé.

/!\ en JS, `else if` s'écrit avec un espace entre les 2 termes.

La structure de contrôle `switch` + n(`case` + `break`) (+ `default:`) permet de spécifier un traitement différent selon la valeur d’une variable.

### Boucles

Toutes les boucles en JS se basent au minimum sur :

- une condition de répétition (on dit aussi « de sortie »)
- des instructions à répéter

et éventuellement sur :

- une gestion fine de la condition de sortie, avec par exemple un compteur numérique (par exemple, boucle for).

Deux instructions sont disponibles dans toutes les boucles et permettent d’en contrôler le fonctionnement :

- il est possible d’interrompre une boucle avec l’instruction `break`
- il est possible d’interrompre l’itération courante et de passer à la suivante avec l’instruction `continue`

#### Boucle WHILE

Tant que**** la condition est vérifiée, j’exécute les instructions : `while(condition) { instructions;}`

#### Boucle DO...WHILE

J’exécute les instructions une première fois, puis **tant que** la condition est vérifiée, je recommence : `do { instructions; } while(condition)`

#### Boucle FOR

**Pour** chaque nouvelle valeur de ma variable de contrôle de boucle, et ce jusqu’à ce que la condition ne soit plus vérifiée, j’exécute les instructions : `for(let i = 0; i < 3; i++) { instructions; }`

#### Boucle FOR...IN

**Pour** chaque proprieté **dans** l’*objet*, j’exécute les instructions : `for(let propriete in object) { instructions; }`

#### Boucle FOR...OF

**Pour** chaque élément **du** *tableau*, j’exécute les instructions : `for(let key of array) { instructions; }`

/!\ cette boucle ne fonctionne pas avec les objets, qui ne sont pas *itérables* (cf paragraphe suivant).

### Enumérable VS itérable

Les termes **énumérable** et **itérable** désignent 2 caractéristiques applicables aux collections, c'est-à-dire à un ensemble d'informations : tableau (JS, php), objet (JS), fichier de balises (HTML), de styles (CSS), etc...

Une collection est énumérable si on peut compter ses éléments mais que l'ordre de ceux-ci importe peu (ex: ma liste de courses).

Une collection itérable est une collection énumérable dont l’**ordre d’énumération est important** (ex: la liste de courses de ma mère qui classe tout par rayon et par ordre de rangement dans le panier).

### Modules JS

Un **module** est un bloc de code cohérent et indépendant. En JS, on place chaque module dans un fichier séparé.

On peut choisir quels éléments d’un module vont être exposés en les précédant d’une déclaration `export`. Ces éléments pourront être importés avec `import` dans d’autres modules ou dans d’autres scripts.

Les modules permettent :

- une *meilleure maintenabilité* du code : par définition un bon module doit être autonome et on doit pouvoir le modifier sans avoir à modifier d’autres scripts
- de *limiter le risque de pollution* (=le fait d’avoir de nombreuses variables différentes dans l’espace global du script et de courir le risque que certaines possèdent le même nom) : les modules possèdent leur propre espace de portée globale et les autres scripts n’y ont pas accès par défaut
- une *meilleure réutilisation* du code : comme les modules sont indépendants et autonomes (s’ils sont créés correctement), on peut les réutiliser dans différents projets, ce qui nous fait gagner beaucoup de temps

Les modules utilisent par défaut le **mode strict** en JavaScript.

Les modules possèdent leur **propre espace global de portée**. Cela signifie que les variables et fonctions définies dans l’espace global d’un module ne seront par défaut pas accessibles aux autres scripts.
Chaque module devra exporter les éléments qu’il souhaite rendre accessible aux autres fichiers et importer les éléments auxquels il souhaite accéder (sous réserve que ces éléments soient importables).

Le code des modules n’est évalué qu’une seule fois. Ainsi, si le code d’un module est importé plusieurs fois dans d’autres modules, le code ne va être exécuté qu’une seule fois (par le premier module qui va en avoir besoin) puis le résultat de cette exécution sera ensuite exporté à tous les autres modules ayant importé de même code.

On peut utiliser un attribut `async` avec les modules afin que ceux-ci s’exécutent de manière asynchrone. Dans ce cas-là, les scripts s’exécuteront dès qu’ils seront prêts. Cela peut être utile dans le cas où l’on souhaite importer des modules qui sont indépendants du reste de la page (modules de statistique, de publicité, etc.).

#### Ressources

- [Les modules JS (MDN)](https://developer.mozilla.org/fr/docs/Web/JavaScript/Guide/Modules)
- [Introduction aux modules](https://fr.javascript.info/modules-intro)
- [Le mode strict](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Strict_mode)

## DOM

**DOM** signifie **D**ocument **O**bject **M**odel, une modélisation/représentation sous forme d'objet de notre document, la page html qu'on consulte représentée sous forme d'objet JS. On dit souvent que c'est un arbre puisqu'il va contenir une représentation de toutes les balises HTML imbriquées dans la page.

Pour voir la représentation en objet on peut utiliser `console.dir()` plutot que `.log()`, pratique pour les morceaux de DOM.

Modifier le DOM (=modifier le contenu de l'objet document) c'est modifier en direct la représentation de notre page HTML consultée dans la fenetre de navigateur de l'utilisateur.

On peut cibler un élément du document grâce à différents sélecteurs (liste non exhaustive):

- `querySelector()` : retourne le PREMIER élement qui correspond au selecteur CSS passé en argument
- `querySelectorAll()` : retourne une **NodeLIst** (= collections de noeuds, que l'on peut manipuler comme un tableau) de tous les élements qui correspondent au selecteur demandé
- `getElementById()` : retourne un élément suivant son Id
- `getElemntsByClassName()` : retourne un objet de type tableau de tous les éléments enfants qui ont tous les noms de classe donnés

Une fois un élement ciblé, on constate qu'il s'agit d'objets avec des propriétés qu'on peut lire, et que l'on peut *modifier*.

Pour *créer* un élement de toute pièce qui n'existe pas encore on utilise `createElement` : `const newElement = document.createElement('section');`

Quand on a créé un élement on peut l'insérer dans un élement parent, à la fin de celui-ci grâce à `append` ou au début avec `prepend`.

#### Ressources

- [Fiche MDN interface **Document**](https://developer.mozilla.org/fr/docs/Web/API/Document)
- [Fiche MDN **Node**](https://developer.mozilla.org/fr/docs/Web/API/Node)
- [Fiche MDN **Element**](https://developer.mozilla.org/fr/docs/Web/API/Element)

### Evènements

Les **événements** sont des actions ou des occurrences qui se produisent dans le système que vous programmez. Le système déclenche un signal quelconque lorsqu'un événement se produit, et fournit également un mécanisme par lequel une action est exécutée automatiquement (ex. un code en cours d'exécution) lorsque l'événement se produit. Dans le cas du Web, les événements sont déclenchés à l'intérieur de la fenêtre du navigateur et tendent à être rattachés à un élément spécifique qui s'y trouve. Il peut s'agir d'un élément unique, d'un ensemble d'éléments, du document HTML chargé dans l'onglet en cours ou toute la fenêtre du navigateur (cf *Ressource "Liste des différents événements"*).

Chaque événement disponible a un **gestionnaire d'événement**, qui est un bloc de code (généralement une fonction JS attachée à un noeud) qui sera exécuté lorsque l'événement se déclenchera. On écoute l'événement qui se produit grâce à un **écouteru d'événement** et le gestionnaire est le code qui est exécuté en réponse à ce qui se passe.

Il est important de noter que les événements web ne font pas partie du langage du noyau JS. Ils sont définis comme *faisant partie des APIs JavaScript intégrées du navigateur*.

#### Ressources

- [Fiche MDN **Eventarget**](https://developer.mozilla.org/fr/docs/Web/API/EventTarget)
- [Liste des différents événements (MDN)](https://developer.mozilla.org/fr/docs/Web/Events#index_des_%C3%A9v%C3%A9nements)
- [Article sur *La gestion des événements en JS* (Alsacréations)](https://www.alsacreations.com/article/lire/578-La-gestion-des-evenements-en-JavaScript.html)

## Cookies & Local Storage

Les **cookies** et le **local storage** sont 2 moyens de mémoriser une information coté client.
Ce sont des moyens d'enregistrer une information sur l'ordinateur utilisateur que l'on pourra retrouver plus tard après en revenant sur son navigateur, l'info restant sur l'ordinateur, sans intervention du serveur.
L'interet  étant de pouvoir mémoriser des préférences, (thème sombre, taille de police,...).

Les script javascript pourront avoir accès à ces informations.

### Cookies &#127850;

Pour une bonne recette de cookies : c'est [ICI](https://docs.google.com/spreadsheets/d/1WQWydXBSNe__duAMfe5vIWd-FPbpKuE9CCjN35WhXgY/edit#gid=0) (ouyi, bon, elle était facile)

Sinon, on peut avoir des cookies pour des tiers, liés à d'autres domaines, pour de la pub, pour des outils liés à un service vidéo comme Youtube.

Le serveur peut aussi etre à l'origine de leur création, et ils peuvent notamment être utilisés pour de l'authentification.

Les cookies peuvent avoir besoin d'un consentement (surtout lorsqu'ils concernent des services tiers), ou pas (par exemple quand ils concernent les préférences de l'utilisateurs sur notre application, *cf ressource "CNIL"*).

Ecriture : `document.cookie = 'lang=français';`

Lecture : 
```JS
console.log(document.cookie); // donne toute la grande String contenant tous les cookie

// pour lire un cookie il faut "un peu" de logique
const cookiesAsArray = document.cookie.split('; ');
// on parcourt le tableau
for (const cookie of cookiesAsArray) {
    // si la chaine commence par le début du cookie qui nous intéresse
    if (cookie.startsWith('nomDuCookieRecherché')) {
        // on explose le cookie
        const cookieInfo = cookie.split('=');
        // pour récupérer que la valeur
        const value = cookieInfo[1];
        // la valeur est trouvée
        console.log(value);
    }
}

// ou bien on peut faire cette logique une fois et la reporter dans une fonction paramétrable et réutilisable, et ça c'est bô!
```

#### Ressources

- [Doc CNIl sur les cookies et traceurs](https://www.cnil.fr/fr/cookies-et-traceurs-que-dit-la-loi)

### Local Storage

Ecriture : `localStorage.setItem('language', français);`

Lecture : `const userAge = localStorage.getItem('age');` //
`console.log(userAge);`

Il peut être plus facile à utiliser et est lié au domaine qui fait tourner notre application (on ne peut pas recupérer des infos qui auraient été mises de coté sur FB alors qu'on est sur YT).

/!\ **Attention le localStorage ne gère que des String**.
Si on veut stocker n'importe quel autre type de données (un objet, un tableau, un booléen, ...), on peut le transformer en String via `JSON.stringify(valueToTransform);`.

Mais on peut ensuite faire machine arrière à la lecture et rendre le bon type à notre string via `JSON.parse`:

```JS
const dataAsString = localStorage.getItem('data');
const data = JSON.parse(valueAsString);
```

### Documentation

- [Présentation MDN de JS](https://developer.mozilla.org/fr/docs/Web/JavaScript)